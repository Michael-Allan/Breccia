Definition of the Breccian language

    - Breccia in practice is a production of documents,
      here defined in formal terms as document nodes.

              │
              │
              ├──────┐
              ╵      │     \ [graphical syntax notation], q.v. at end notes
           document  ▲
             node    │
              ╷      │
              ├──────┘
              │
              │
              ▼

            figure, The collective form of Breccia.

    document node
        - A Breccian document in formal terms.
        - It divides into an optional head formed as a bare descriptor,
          and an optional body formed as a sequence of body nodes.

                       │
                 ┌─────┤         ┐
                 │     ╵         │
                 │ descriptor    │ head
                 │     ╷         │
                 └─────┤         ┘
                       │
                  ┌────┤         ┐
                  │    ├───┐     │
                  │    ╵   │     │
                  │  body  ▲     │ body
                  │  node  │     │
                  │    ╷   │     │
                  │    ├───┘     │
                  └────┤         ┘
                       │
                       ▼

    document title
        - The document title, if any, is determined by the first nodal head in document order
          that yields a non-empty result after collapsing the whitespace of the relevant part
          of its content according to head type:
            • document head or point head
                - The relevant part is the whole head exclusive of commentary and static blocks.
            • divider
                - The relevant part is its first label.



    ━━━━━━━━━━━━━
     Aside point
    ─────────────
        / A specialized material point.
        - A point with a bullet comprising ‘/’.
        - It is a point of less prominence than its place would otherwise suggest.
            / E.g. one to which the reader should give less attention on a first reading.
        - Its descriptor, if present, is largely free form.
            : see `Most descriptors are largely free form.$` @ `^^ Descriptor$`


    ━━━━━━━━━━━━━━━━━━━━━━
     Associative reference
    ──────────────────────
        / A command point.
        - It indicates a resource (the referent) and associates with it one or more preceding
          character sequences (the referrer, or referrers).
        - Its descriptor has this form:

                            referrer                referent
               ─── gap ──┬── clause ──┬─ gap ─┬──┬── clause ────▶
                         │            │       │  │
                         │            └───────┘  │
                         └───────────────────────┘

            figure, The form of the descriptor of an associative reference.

        - The referrer clause indicates the referrer or referrers.
        - The referent clause indicates the referent.
        - A single referrer may be associated with multiple referents.
            / via multiple, sibling references that indicate the same referrer
        - Multiple referrers may be overlapped or nested in any manner.
            / via multiple, sibling references
            / via a single reference that indicates multiple referrers at once

        referrer clause
            - The referrer clause indicates the referrer, or referrers, by a pattern of text
              occuring in the parent head of the reference.

                   ───╴‘re’╶─┬─ gap ─┬─╴‘`’╶─ pattern ─╴‘`’╶────▶
                             │       │
                             └───────┘

                - Failing a parent head, the reference is misplaced and the document malformed.
                    / This occurs only when the parent is a document node without a descriptor.
            - It works thus:
                if( the pattern contains one or more subexpression grouping constructs ‘(…)’ )
                    : re `subexpression grouping constructs`
                      see https://perldoc.perl.org/perlreref.html#SYNTAX
                    for( each match of the pattern within the parent head of the reference )
                        if( at least one subexpression captures a text sequence )
                            + Set as a referrer the union of all captured text sequences.
                else
                    for( each match of the pattern within the parent head of the reference )
                        + Set as a referrer the whole of the matching text.
            - The referrer clause is optional.
                - If omitted, then the whole of the parent head is taken as the referrer.

        referent clause
            - The referent clause indicates the referent.

                                                        URI
                      ┌─╴‘join’╶─┐              ┌─── reference ───┐
                   ───┤          ├──┬─ gap ─┬───┤                 ├────▶
                      └──╴‘see’╶─┘  │       │   │    impliable    │
                                    └───────┘   └────  node   ────┘
                      └───────────┘                  indicator
                       referential
                         command

                : re `‘(join)’` see `^^ Jointer$`
                : re `‘(see)’` see `^^ Pointer$`
                : re `(URI)$.*(reference)` see https://tools.ietf.org/html/rfc3986#section-4.1

            - It works thus:
                if( a URI reference is given )
                    + Set as referent the resource indicated by the URI reference.
                else
                    - An impliable node indicator is given.
                    if( its first component (the principal node indicator) is omitted )
                        + Set as first component a principal node indicator
                          with a pattern `p` formed thus:
                            if( the reference has a referrer clause )
                                + Set `p` to the pattern given in the referrer clause.
                                + Set `p` to broadened to division title( `p` ).
                                    : see `^^broadened to division title\( pattern \)$`
                                + Anchor `p` by appending ‘$’.
                            else
                                + Set `p` to generalized pattern( parent head of reference ).
                                    : see `^^generalized pattern\( nodal head \)$`
                    if( the pattern of its principal node indicator contains
                         one or more subexpression grouping constructs ‘(…)’ )
                        : re `subexpression grouping constructs`
                          see https://perldoc.perl.org/perlreref.html#SYNTAX
                        + Set as referent the union of the text sequences they capture.
                    else
                        + Set as referent the whole of the indicated node.

            referential command
                - The referential command determines the type and overall function
                  of the associative reference.
                    : re `type` see `^^◇ associative reference$` @ `^^typology$` @ `^^ Node$`



    ━━━━━━━━
     Bullet
    ────────
        / Part of a point head.
        - It is confined between boundaries (diagram below) which partly determine its internal form.

                 perfect   ┊      start                             end             ┊   descriptor,
               indentation ┊╶─── sequence ──┬──┬── interior ──┬── character ──┬───▶ ┊  head successor,
                           ┊                │  │              │               │     ┊ or end of document
                                            │  └──────────────┘               │     ┊
                                            └─────────────────────────────────┘
                                    i                 ii            iii

            : re `head successor` see `^^\| the head successor$` @ `^^ Node$`
        - While the precise internal form varies according to the point type, every bullet is formally
          conditioned by basic contraints operating in several regions, here numbered i, ii, iii.
        i. start sequence, one of:
            | a character that is neither whitespace nor backslash (5C) nor divider mark
                : see `^^character identification$` @ `^^ Notes$`
            | one or more backslashes immediately followed by
              a character that is neither whitespace nor backslash
                \ Whitespace would make it a sequence of a comment block, not a bullet.
        ii. interior
            - Coming after the start character and before the end character.
            - Here the bullet may contain spacing characters, and nowhere else.
                - One or more plain spaces (20) may follow an alphanumeric character.
                    - Following any other character C would expel both from the interior, making C
                      either the end character if it meets its constraints, or part of the end boundary.
                - One or more no-break spaces (A0) may follow any non-alphanumeric character
                  other than either a plain space, or a backslash occuring in a backslash sequence
                  at the start of the bullet. \ The backslash case is excluded because it would
                    \ complicate `Emacs/Breccia_mode.el`, and anyway appears to be useless.
                    - Here the excluded sequences are not expulsive, rather they are simply forbidden.
                - No other whitespace is allowed, namely no newline: it could not be part of a bullet,
                  only of its end boundary.
        iii. end character, a character that is none of:
            | whitespace
            | a backslash subsequent to a plain space of the interior
                \ That would start the end boundary in the form of inline commentary,
                \ part of a descriptor.



    ━━━━━━━━━━━━━━━
     Command point
    ───────────────
        / A formal point.
        - A point with a bullet comprising ‘:’.
        - The form of its descriptor varies with the type of command point.
            : re `type of command point` see `^^typology$` @ `^^ Node$`
            - Only in the case of *null command point* may the descriptor be omitted.
        - Processors interpret command points and execute their commands in document order.

        null command point
            - A command point that does nothing.
                / It is an artifact of formal consistency, of a descriptor being optional in the head
                  of all point types.
            - Its descriptor, if present, has this form:

                   ─── gap ───▶

                figure, The form of a descriptor as it appears in a null command point.



    ━━━━━━━━━━━━
     Commentary
    ────────────
        / Part of a descriptor.
        - A part of the document intended for authors, publishers and other atypical readers.
        form
            / per line
            - Begins with a sequence of one or more consecutive backslashes ‘\’ (5C)
              immediately preceded by a space (20) or the line start,
              and immediately followed by a space or the line end.
                : see `^^character identification$` @ `^^ Notes$`
            - Continues to the line end.
        inline commentary
            - Commentary subsequent to non-commentary on the same line. \ ‘Commentary’ as opposed
                \ to ‘a comment’, because the comment as a whole may extend across lines.
        block commentary
            comment block
                - A sequence of lines comprising commentary alone.
                - A comment block is part of the node head that starts before it in document order.
                    - In the case of document node, the head may comprise a comment block alone.
            comment block label
                - In a comment block.
                - In a line of commentary delimited by two or more consecutive backslashes ‘\\’.
                - The label is the part subsequent to the backslash delimiter,
                  exclusive of leading and trailing whitespace.



    ━━━━━━━━━━━━
     Descriptor
    ────────────
        / Part of a document head or point head.
        - Elaborative, explanatory text at the head of a document or point.
        - It starts with a gap.

                           · · · ·
                           ·     ·       ┊  head successor,
               ─── gap ─── ·  ?  · ────▶ ┊ or end of document
                           ·     ·       ┊
                           · · · ·

            : re `head successor` see `^^\| the head successor$` @ `^^ Node$`
        - What follows the gap (?) depends on the type of node in which the descriptor appears.
        - Here most descriptors are largely free form, constrained only by the end boundary
          of their head (as shown).
            - The descriptor of a formal point, however, is further constrained.
                : re `formal point` see `^^◇ formal point$` @ `^^typology$` @ `^^ Node$`
        gap
            - A formal intermediary within a descriptor.

                  ┌─────────────────────╴◀───────────────────────────────────────┐
                  │                                                              │
                  │  ┌────────────────────────╴‘ ’╶───────────────────────────┐  │
                  │  │                                                        │  │
               ───┴──┤                                         block          ├──┴───▶
                     │        inline                    ┌─── commentary ───┐  │
                     └──┬── commentary ──┬── newline ───┤                  ├──┘
                        │                │              ├── static block ──┤
                        └────────────────┘              │                  │
                                                        └──────────────────┘



    ━━━━━━━━━━
     Division
    ──────────
        / A body node.
        - It forms a distinctive or otherwise atypical part of the document.
            / E.g. one too large (or small) to comfortably form as a point.
            - Depending on whether the division has a body, the part formed comprises either:
                | the division itself (a division with a body)
                | the division and its subsequent siblings (a division without a body, a divider alone)
        divider
            - The head of a division.
            - It comprises one or more divider segments.
            - No two dividers are contiguous; rather they combine as one divider of multiple segments.
        divider segment
            - Begins with a perfectly indented divider mark.
            - The end boundary is the next appearance in document order of either
              a divider segment, a point, or the end of the document.
        divider mark
            - Unicode 2500-259F.
            / Divider mark = drawing character ∪ inversion mark.
            drawing character
                - Unicode 2500-2587, 2589-258F, 2591-259F.
            inversion mark
                - Unicode 2588 (full block), 2590 (right half block).
        division label
            - A sequence of non divider-mark characters in a divider,
              exclusive of leading and trailing whitespace.
            inverse label
                - A sequence of non divider-mark, non newline characters in a divider,
                  exclusive of leading and trailing whitespace and preceded on the same line
                  by an inversion mark, with at most (the leading) space characters between the two.
                - Normally the inverse label, together with any leading or trailing whitespace,
                  is presented in inverse video.
                    - Except that any inline commentary is still presented in plain video.
                - Where a full block character succeeds an inversion mark on the same line,
                  with at most non divider-mark characters in between,
                  that full block is disabled as an inversion mark.
                    / Viz. the full block pairs with the preceding inversion mark,
                      and by itself does not start a new inverse label.
                    / Viz. a single full block trailing an inverse label cannot start
                      a second inverse label.
            division title
                - A division label that leads a line, with at most space characters in front.
                - Normally it is displayed with greater prominence than an ordinary label,
                  e.g. using a bold face.



    ━━━━━━━━━━━━━━━━━
     Exception point
    ─────────────────
        / A specialized material point.
        - Bullet comprising or terminated ‘!!’.
        - It is a point of urgency for the attention of authors.
            / E.g. indicating an error in the document.



    ━━━━━━━━━━━━━━━
     Generic point
    ───────────────
        / A material point.
        - A non specialized point, a point for which the language defines no special role or bullet form.
        - Its bullet is largely free form, conditioned only by the basic constraints.
            : re `basic constraints` see `(basic constraints) ` @ `^^ Bullet$`
        - Likewise its descriptor, if present, is largely free form.
            : see `Most descriptors are largely free form.$` @ `^^ Descriptor$`



    ━━━━━━━━━
     Jointer
    ─────────
        - An associative reference with a referential command of `join`.
        - A jointer stands for the body of its referent node, and associates it with the referrer.
        example

              join foo/bar.br

        form

              join  IMPLIABLE_NODE_INDICATOR

            IMPLIABLE_NODE_INDICATOR
                - An impliable node indicator.
                - Indicates the referent node.
                - The default value for the first component of the indicator, or the implied value
                  of the whole indicator if all its components are omitted, is a principal node indicator
                  formed using the generalized pattern of the jointer’s parent head.
                    : re `generalized pattern` see `^^generalized_pattern\( nodal_head \)$`
                - Will not match where the jointer would have no effect.
                    : re `effect` see @ `^^ Jointer$`
                    / This stops the jointer matching its own parent, for instance.
        effect
            - On behalf of the referrer, the parent of a jointer gains for a child (subjoint child)
              each child of the referent node that does not duplicate a pre-existing child.
            - By the same token, the children of a referent node gain for a parent (surjoint parent)
              each parent of the jointer that does not duplicate a pre-existing parent.
            - In both cases the duplication test ignores variations in commentary and whitespacing.
            - Where a subjoint child is itself a jointer, or a surjoint parent itself the referent node
              of a jointer, the effect applies recursively.



    ━━━━━━
     Node
    ──────
        - The basic formal unit of Breccian composition, hierarchy and order.

        typology
            • document node
            ◇ body node
                • division
                ◇ point
                    ◇ formal point
                        ◇ command point
                            ◇ associative reference
                                • jointer
                                • pointer
                            • null command point
                    ◇ material point
                        ◇ specialized material point
                            • aside point
                            • exception point
                            • task point
                        • generic point

        abstract form
            - A node divides formally into two parts: a head and a body.

                      │
                      ╵
                   · · · ·      ┐
                   ·     ·      │
                   ·  ?  ·      │ head
                   ·     ·      │
                   · · · ·      ┘
                      ╷
                      │
                 ┌────┤
                 │    ├───┐     ┐
                 │    ╵   │     │
                 │  body  ▲     │ body
                 │  node  │     │
                 │    ╷   │     │
                 │    ├───┘     ┘
                 └────┤
                      │
                      ▼

            head
                - The part of a node exclusive of its children.
                - Its internal form (abstracted from the diagram) varies according to the node type.
                - Its end boundary (not fully shown) always comprises one of:
                    | the head successor
                        - The head successor (S) is the node succeeding the head in document order.
                        - In terms relative to the head’s own node N, S is the first applicable of:
                            | the first child of N
                                / in its body, that is
                            | the next sibling of N
                            | the next sibling of the nearest ancestor of N which is not itself
                              a final sibling
                    | the end of the document
            body
                - The part of a node comprising its children alone; a sequence of body nodes.
                - A body is always optional: regardless of the node type, it may be omitted.

        nodal relatives
            • parent
                - The parent of a node is the first applicable of:
                    | its nearest (in document order) nodal precedecessor of less indentation
                    | the document node
            • child
                - A node that has a parent.
                - All body nodes are children.
                - No document node is a child.


        ──────────────────────────
         impliable node indicator
        ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
            - An indicator of a node, here referred to as ‘the principal node’.

                                           ┌─────────╴◀─────────────┐
                                           │                        │
                          principal        │             ancestral  │                    referent
                   ───┬──╴  node   ╶──┬──┬─┴─┬─ gap ─┬──╴  node   ╶─┴──┬──┬──┬─ gap ─┬── document ──┬───▶
                      │   indicator   │  │   │       │   indicator     │  │  │       │   indicator  │
                      │               │  │   └───────┘                 │  │  └───────┘              │
                      └───────────────┘  └─────────────────────────────┘  └─────────────────────────┘

            - Any reference to this form will be accompanied by the specification of a default value
              for its first component (the principal node indicator), which will also serve as
              the implied value of the whole indicator if all its components are omitted.
            - An impliable node indicator may be used to indicate a non-Breccian referent.
                - Where a processor is unable to find such a referent, or to deal with it,
                  it should not prevent the reader trying to deal with it manually.

            principal node indicator
                - A direct indicator of the principal node by the pattern of its text.

                       ───╴‘`’╶─ pattern ─╴‘`’╶───▶

                - It works by indicating the return value of this procedure:
                    if( the pattern contains one or more subexpression grouping constructs ‘(…)’ )
                        : re `subexpression grouping constructs`
                          see https://perldoc.perl.org/perlreref.html#SYNTAX
                        for( each match of the pattern )
                            if( at least one subexpression captures a text sequence,
                                 and all captured text sequences lie within the same nodal head )
                                + Set as indicated the nodal head’s node.
                    else
                        for( each match of the pattern )
                            + Set as indicated the node whose head contains the first matched character
                              in document order.
                    if( exactly one node is indicated )
                        return( the indicated node )
                    if( the referent document is Breccian )
                        throw( error, the indicator is ambiguous )

                generalized pattern( nodal head )
                    / Returns a generalized pattern of the given nodal head, which is commonly used
                      to specify the default value for a principal node indicator.
                    + Set `p` to the text of the given `nodal head`.
                    + Trim `p` of commentary.
                    + Trim `p` of leading whitespace on its first line.
                    + Trim `p` of trailing whitespace.
                    + Set `p` to literalized pattern( `p` ).
                        : see `^^literalized pattern\( string \)$`
                    + Collapse all remaining whitespace of `p` to ‘\s+’.
                        / Neutralizing differences in indentation and line wrapping.
                    if( `nodal head` is a divider )
                        + Anchor `p` by prepending ‘^^’.
                        for( each repetitive sequence (S) of a drawing character (C) in `p` )
                            + Collapse S to a single C followed by ‘+’.
                            / Neutralizing differences in horizontal length, e.g. owing to indentation.
                    else if( `p` ends with a literalized ‘+’ )
                        / Then `nodal head` may comprise a task bullet.
                        if( `p` does not *comprise* a literalized ‘+’ )
                            / Then the (potential) bullet here is not ‘+’ alone.
                            + Append ‘?’.
                                / Making the (potential) task mark ‘+’ optional in order to broaden
                                  the pattern and match other bullet types, e.g. a generic bullet.
                                / A use case here is to join a generic head ‘foo’, for instance,
                                  from a task head ‘foo+’, in order to task ‘foo’ for action.
                        + Set `p` to broadened to division title( `p` ).
                            : see `^^broadened to division title\( pattern \)$`
                    + Anchor `p` by appending ‘$’.
                    return( `p` )

                broadened to division title( p )
                    / Returns the given pattern `p` broadened to match a division title.
                    + Anchor `p` by prepending ‘^ *’.
                    + Ensure that `p` functions in *case insensitive* mode (`i`).
                        : re `\*case insensitive\* mode`
                          see https://perldoc.perl.org/perlreref.html#OPERATORS
                    return( `p` )

            ancestral node indicator
                - An indicator of an ancestor of the principal node.
                - It indicates the ancestor by the pattern of its text.

                       ───╴‘@’╶─┬─ gap ─┬─╴‘`’╶─ pattern ─╴‘`’╶───▶
                                │       │
                                └───────┘

                - Where multiple indicators appear in series, each successor gives the ancestral scope
                  of its predecessor.

            referent document indicator
                - An indicator of the referent document, the document of the principal node.

                       ───╴‘@’╶─┬─ gap ─┬── URI reference ────▶
                                │       │
                                └───────┘

                    : re `URI reference` see https://tools.ietf.org/html/rfc3986#section-4.1



    ━━━━━━━━━━━━━━━━━━
     Pattern matching
    ──────────────────
        / Apropos the procedure of pattern matching based on regular expressions.
        pattern
            - A modified, Perl compatible regular expression in multiline mode (`m`).
                : re `Perl compatible regular expression` see https://perldoc.perl.org/perlreref.html
                : re `multiline mode` see https://perldoc.perl.org/perlreref.html#OPERATORS
            - Its modifications are:
                • `\t` symbolizes not a tab, but one unit of perfect indentation
                • `^^` expands to `^\t*`, an anchored, leading sequence of perfect indentation
                • literal backquote characters ‘`’ are forbidden
                    - Patterns in Breccia are formally delimited using backquote characters ‘`’.
                    - To put a backquote character ‘`’ in a pattern, escape it with a backslash ‘\`’.
                    - Backslashes themselves are likewise escapable, of course.
                        / The trailing delimiter character in pattern ‘foo\\`’,
                          for example, is not escaped by the preceding backslash
                          because the backslash itself is escaped.
                • inline commentary is forbidden
                    - No start sequence of inline commentary may appear in the pattern.
                        / For example ‘·\·’ or ‘·\\·’, where ‘·’ stands for a space character.
                    - Replace it with an equivalent.
                        / For example ‘··’ and ‘·\N{U+005C}·’ respectively.
        literalized pattern( string )
            / Returns the given string as a literally enquoted pattern, as defined for Perl `quotemeta`.
                : re `quotemeta` see https://perldoc.perl.org/functions/quotemeta.html



    ━━━━━━━
     Point
    ───────
        / A body node.
        - Its head comprises a perfectly indented bullet, and often a descriptor.

               start ┊                                                     ┊  head successor,
                of   ┊╶───╴  perfect  ╶─── bullet ──┬── descriptor ──┬───▶ ┊ or end of document
               line  ┊     indentation              │                │     ┊
                                                    └────────────────┘

                : re `head successor` see `^^\| the head successor$` @ `^^ Node$`
            figure, The form of a point head.

        - Both the internal forms of the bullet and descriptor, and whether the descriptor may be
          omitted, depend on the type of point.
            : re `type of point` see `^^typology$` @ `^^ Node$`



    ━━━━━━━━━
     Pointer
    ─────────
        - An associative reference with a referential command of `see`.
        - It directs the reader’s attention from the referrer to the referent.



    ━━━━━━━━━━━━━━
     Static block
    ──────────────
        / Part of a descriptor.
        - A part of the document containing text which is not in Breccian form.
        - It comprises one or more lines in contiguous sequence, each headed by a no-break space (A0).
            : see `^^character identification$` @ `^^ Notes$`
        - It enables the author to lay out a section of text freely,
          unconstrained by Breccia’s rules of indentation.
            - Regardless of its indentation, a static block does not interrupt the nodal head
              in which it occurs; rather the head continues blindly through the block.
            - A presenter capable of reformatting the layout of a Breccian text is forbidden to alter
              the layout of a static block rightward of its leading no-break spaces.
        - Character restrictions, however, still apply.
            : see `^^allowed whitespace$` @ `^^ Whitespace$`



    ━━━━━━━━━━━━
     Task point
    ────────────
        / A specialized material point.
        - Bullet comprising or terminated ‘+’.
        / Task points are justified by the Breccian purpose of drafting,
          for which inline tasking is a useful aid.
            : re `purpose of drafting` see `^^Breccia$` @ lexicon.brec



    ━━━━━━━━━━━━
     Whitespace
    ────────────
        / A class of character.
        allowed whitespace
            : see `^^character identification$` @ `^^ Notes$`
            • space (20)
            • newline (A, D)
            • no-break space (A0) as described for use in bullets and static blocks
            / Allowing any other horizontal whitespace (9, 2000-200A, 202F, 205F, 3000)
              would be too confusing here, where simple spacing can determine the syntax.
        perfect indentation
            - Perfect indentation comes at the start of a line.
            - It comprises zero or more segments of space characters, each four in length.

                           ┌─────────╴◀───────────┐
               start ┊     │                      │
                of   ┊╶──┬─┴─╴‘ ’╶╴‘ ’╶╴‘ ’╶╴‘ ’╶─┴─┬───▶
               line  ┊   │                          │
                         └──────────────────────────┘



    ━━━━━━━
     Notes
    ───────
        character identification
            - The identifiers here are hexadecimal codes of the Unicode standard.
                : re `Unicode standard` see https://www.unicode.org/standard/standard.html
     \ [graphical syntax notation]
     \      - The present text uses syntax diagrams because it is aimed at Breccian authors in general,
     \        who are not expected to be comfortable with a textual notation such as Backus-Naur Form.



                                        \ Copyright © 2019, Michael Allan and contributors.  Licence MIT.
